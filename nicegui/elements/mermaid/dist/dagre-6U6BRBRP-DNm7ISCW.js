import{f as e}from"./chunk-FASC7IG4-_FzvpI2d.js";import{m as t}from"./chunk-ZN7TASNU-DDZ3ESNM.js";import{m as n,aN as r,aO as a,aP as i,aQ as d,t as o,h as s,aR as l,aS as g,aw as c,aT as f,aB as h,ax as p,av as u,aU as w,aV as v}from"./index-Bd_j0xvv.js";import{s as y,_ as m,J as X}from"./chunk-5ZJXQJOJ-BQpwB-Bn.js";function N(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:E(e),edges:b(e)};return y(e.graph())||(t.value=m(e.graph())),t}function E(e){return X(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),a={v:t};return y(n)||(a.value=n),y(r)||(a.parent=r),a})}function b(e){return X(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return y(t.name)||(r.name=t.name),y(n)||(r.value=n),r})}n(N,"write"),n(E,"writeNodes"),n(b,"writeEdges");var C=new Map,S=new Map,x=new Map,I=n(()=>{S.clear(),x.clear(),C.clear()},"clear"),D=n((e,t)=>{let n=S.get(t)||[];return o.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),O=n((e,t)=>{let n=S.get(t)||[];return o.info("Descendants of ",t," is ",n),o.info("Edge is ",e),e.v!==t&&e.w!==t&&(n?n.includes(e.v)||D(e.v,t)||D(e.w,t)||n.includes(e.w):(o.debug("Tilt, ",t,",not in descendants"),!1))},"edgeInCluster"),k=n((e,t,n,r)=>{o.warn("Copying children of ",e,"root",r,"data",t.node(e),r);let a=t.children(e)||[];e!==r&&a.push(e),o.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(a=>{if(t.children(a).length>0)k(a,t,n,r);else{let i=t.node(a);o.info("cp ",a," to ",r," with parent ",e),n.setNode(a,i),r!==t.parent(a)&&(o.warn("Setting parent",a,t.parent(a)),n.setParent(a,t.parent(a))),e!==r&&a!==e?(o.debug("Setting parent",a,e),n.setParent(a,e)):(o.info("In copy ",e,"root",r,"data",t.node(e),r),o.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==r,"node!==clusterId",a!==e));let d=t.edges(a);o.debug("Copying Edges",d),d.forEach(a=>{o.info("Edge",a);let i=t.edge(a.v,a.w,a.name);o.info("Edge data",i,r);try{O(a,r)?(o.info("Copying as ",a.v,a.w,i,a.name),n.setEdge(a.v,a.w,i,a.name),o.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):o.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",r," clusterId:",e)}catch(e){o.error(e)}})}o.debug("Removing node",a),t.removeNode(a)})},"copy"),J=n((e,t)=>{let n=t.children(e),r=[...n];for(let a of n)x.set(a,e),r=[...r,...J(a,t)];return r},"extractDescendants"),G=n((e,t,n)=>{let r=e.edges().filter(e=>e.v===t||e.w===t),a=e.edges().filter(e=>e.v===n||e.w===n),i=r.map(e=>({v:e.v===t?n:e.v,w:e.w===t?t:e.w})),d=a.map(e=>({v:e.v,w:e.w}));return i.filter(e=>d.some(t=>e.v===t.v&&e.w===t.w))},"findCommonEdges"),P=n((e,t,n)=>{let r,a=t.children(e);if(o.trace("Searching children of id ",e,a),a.length<1)return e;for(let e of a){let a=P(e,t,n),i=G(t,n,a);if(a){if(!(i.length>0))return a;r=a}}return r},"findNonClusterChild"),A=n(e=>C.has(e)&&C.get(e).externalConnections&&C.has(e)?C.get(e).id:e,"getAnchorId"),B=n((e,t)=>{if(!e||t>10)o.debug("Opting out, no graph ");else{o.debug("Opting in, graph "),e.nodes().forEach(function(t){e.children(t).length>0&&(o.warn("Cluster identified",t," Replacement id in edges: ",P(t,e,t)),S.set(t,J(t,e)),C.set(t,{id:P(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){let n=e.children(t),r=e.edges();n.length>0?(o.debug("Cluster identified",t,S),r.forEach(e=>{D(e.v,t)^D(e.w,t)&&(o.warn("Edge: ",e," leaves cluster ",t),o.warn("Descendants of XXX ",t,": ",S.get(t)),C.get(t).externalConnections=!0)})):o.debug("Not a cluster ",t,S)});for(let t of C.keys()){let n=C.get(t).id,r=e.parent(n);r!==t&&C.has(r)&&!C.get(r).externalConnections&&(C.get(t).id=r)}e.edges().forEach(function(t){let n=e.edge(t);o.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),o.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let r=t.v,a=t.w;if(o.warn("Fix XXX",C,"ids:",t.v,t.w,"Translating: ",C.get(t.v)," --- ",C.get(t.w)),C.get(t.v)||C.get(t.w)){if(o.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),r=A(t.v),a=A(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){let a=e.parent(r);C.get(a).externalConnections=!0,n.fromCluster=t.v}if(a!==t.w){let r=e.parent(a);C.get(r).externalConnections=!0,n.toCluster=t.w}o.warn("Fix Replacing with XXX",r,a,t.name),e.setEdge(r,a,n,t.name)}}),o.warn("Adjusted Graph",N(e)),T(e,0),o.trace(C)}},"adjustClustersAndEdges"),T=n((e,n)=>{if(o.warn("extractor - ",n,N(e),e.children("D")),n>10)return void o.error("Bailing out");let r=e.nodes(),a=!1;for(let t of r){let n=e.children(t);a=a||n.length>0}if(a){o.debug("Nodes = ",r,n);for(let a of r)if(o.debug("Extracting node",a,C,C.has(a)&&!C.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",n),C.has(a))if(!C.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){o.warn("Cluster without external connections, without a parent and with children",a,n);let r="TB"===e.graph().rankdir?"LR":"TB";C.get(a)?.clusterData?.dir&&(r=C.get(a).clusterData.dir,o.warn("Fixing dir",C.get(a).clusterData.dir,r));let i=new t({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});o.warn("Old graph before copy",N(e)),k(a,e,i,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:C.get(a).clusterData,label:C.get(a).label,graph:i}),o.warn("New graph after copy node: (",a,")",N(i)),o.debug("Old graph after copy",N(e))}else o.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!C.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),n),o.debug(C);else o.debug("Not a cluster",a,n);r=e.nodes(),o.warn("New list of nodes",r);for(let t of r){let r=e.node(t);o.warn(" Now next level",t,r),r?.clusterNode&&T(r.graph,n+1)}}else o.debug("Done, no node has children",e.nodes())},"extractor"),R=n((e,t)=>{if(0===t.length)return[];let n=Object.assign([],t);return t.forEach(t=>{let r=e.children(t),a=R(e,r);n=[...n,...a]}),n},"sorter"),j=n(e=>R(e,e.children()),"sortNodesByHierarchy"),F=n(async(t,r,a,i,d,s)=>{o.warn("Graph in recursive render:XAX",N(r),d);let y=r.graph().rankdir;o.trace("Dir in recursive render - dir:",y);let m=t.insert("g").attr("class","root");r.nodes()?o.info("Recursive render XXX",r.nodes()):o.info("No nodes found for",r),r.edges().length>0&&o.info("Recursive edges",r.edge(r.edges()[0]));let X=m.insert("g").attr("class","clusters"),E=m.insert("g").attr("class","edgePaths"),b=m.insert("g").attr("class","edgeLabels"),S=m.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(e){let t=r.node(e);if(void 0!==d){let t=JSON.parse(JSON.stringify(d.clusterData));o.trace("Setting data for parent cluster XXX\n Node.id = ",e,"\n data=",t.height,"\nParent cluster",d.height),r.setNode(d.id,t),r.parent(e)||(o.trace("Setting parent",e,d.id),r.setParent(e,d.id,t))}if(o.info("(Insert) Node XXX"+e+": "+JSON.stringify(r.node(e))),t?.clusterNode){o.info("Cluster identified XBX",e,t.width,r.node(e));let{ranksep:n,nodesep:d}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:n+25,nodesep:d});let c=await F(S,t.graph,a,i,r.node(e),s),f=c.elem;l(t,f),t.diff=c.diff||0,o.info("New compound node after recursive render XAX",e,"width",t.width,"height",t.height),g(f,t)}else r.children(e).length>0?(o.trace("Cluster - the non recursive path XBX",e,t.id,t,t.width,"Graph:",r),o.trace(P(t.id,r)),C.set(t.id,{id:P(t.id,r),node:t})):(o.trace("Node - the non recursive path XAX",e,S,r.node(e),y),await c(S,r.node(e),{config:s,dir:y}))})),await n(async()=>{let e=r.edges().map(async function(e){let t=r.edge(e.v,e.w,e.name);o.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),o.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(r.edge(e))),o.info("Fix",C,"ids:",e.v,e.w,"Translating: ",C.get(e.v),C.get(e.w)),await f(b,t)});await Promise.all(e)},"processEdges")(),o.info("Graph before layout:",JSON.stringify(N(r))),o.info("############################################# XXX"),o.info("###                Layout                 ### XXX"),o.info("############################################# XXX"),e(r),o.info("Graph after layout:",JSON.stringify(N(r)));let x=0,{subGraphTitleTotalMargin:I}=h(s);return await Promise.all(j(r).map(async function(e){let t=r.node(e);if(o.info("Position XBX => "+e+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t?.clusterNode)t.y+=I,o.info("A tainted cluster node XBX1",e,t.id,t.width,t.height,t.x,t.y,r.parent(e)),C.get(t.id).node=t,p(t);else if(r.children(e).length>0){o.info("A pure cluster node XBX1",e,t.id,t.x,t.y,t.width,t.height,r.parent(e)),t.height+=I,r.node(t.parentId);let n=t?.padding/2||0,a=t?.labelBBox?.height||0,i=a-n||0;o.debug("OffsetY",i,"labelHeight",a,"halfPadding",n),await u(X,t),C.get(t.id).node=t}else{let e=r.node(t.parentId);t.y+=I/2,o.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",e,e?.offsetY,t),p(t)}})),r.edges().forEach(function(e){let t=r.edge(e);o.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t),t),t.points.forEach(e=>e.y+=I/2);let n=r.node(e.v);var d=r.node(e.w);let s=w(E,t,C,a,n,d,i);v(t,s)}),r.nodes().forEach(function(e){let t=r.node(e);o.info(e,t.type,t.diff),t.isGroup&&(x=t.diff)}),o.warn("Returning from recursive render XAX",m,x),{elem:m,diff:x}},"recursiveRender"),L=n(async(e,n)=>{let l=new t({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),g=n.select("g");r(g,e.markers,e.type,e.diagramId),a(),i(),d(),I(),e.nodes.forEach(e=>{l.setNode(e.id,{...e}),e.parentId&&l.setParent(e.id,e.parentId)}),o.debug("Edges:",e.edges),e.edges.forEach(e=>{if(e.start===e.end){let t=e.start,n=t+"---"+t+"---1",r=t+"---"+t+"---2",a=l.node(t);l.setNode(n,{domId:n,id:n,parentId:a.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),l.setParent(n,a.parentId),l.setNode(r,{domId:r,id:r,parentId:a.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),l.setParent(r,a.parentId);let i=structuredClone(e),d=structuredClone(e),o=structuredClone(e);i.label="",i.arrowTypeEnd="none",i.id=t+"-cyclic-special-1",d.arrowTypeStart="none",d.arrowTypeEnd="none",d.id=t+"-cyclic-special-mid",o.label="",a.isGroup&&(i.fromCluster=t,o.toCluster=t),o.id=t+"-cyclic-special-2",o.arrowTypeStart="none",l.setEdge(t,n,i,t+"-cyclic-special-0"),l.setEdge(n,r,d,t+"-cyclic-special-1"),l.setEdge(r,t,o,t+"-cyc<lic-special-2")}else l.setEdge(e.start,e.end,{...e},e.id)}),o.warn("Graph at first:",JSON.stringify(N(l))),B(l),o.warn("Graph after XAX:",JSON.stringify(N(l)));let c=s();await F(g,l,e.type,e.diagramId,void 0,c)},"render");export{L as render};
//# sourceMappingURL=dagre-6U6BRBRP-DNm7ISCW.js.map
