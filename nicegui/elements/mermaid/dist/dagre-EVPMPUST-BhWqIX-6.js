import{l as e}from"./chunk-4BPNZXC3-BmCtVoUq.js";import{m as n,aA as t,aB as r,aC as a,aD as i,J as d,Q as o,aE as s,aF as l,aG as g,aH as c,am as f,aI as h,aJ as p,aK as u,aL as w}from"./index-Dne072Ek.js";import{s as m}from"./chunk-BOP2KBYH-DSA32-lu.js";import{b as v}from"./chunk-6XGRHI2A-CSmXlrJf.js";import"./chunk-BKDDFIKN-CmrN6bhn.js";var y=new Map,X=new Map,E=new Map,N=n(()=>{X.clear(),E.clear(),y.clear()},"clear"),b=n((e,n)=>{let t=X.get(n)||[];return d.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),C=n((e,n)=>{let t=X.get(n)||[];return d.info("Descendants of ",n," is ",t),d.info("Edge is ",e),e.v!==n&&e.w!==n&&(t?t.includes(e.v)||b(e.v,n)||b(e.w,n)||t.includes(e.w):(d.debug("Tilt, ",n,",not in descendants"),!1))},"edgeInCluster"),x=n((e,n,t,r)=>{d.warn("Copying children of ",e,"root",r,"data",n.node(e),r);let a=n.children(e)||[];e!==r&&a.push(e),d.warn("Copying (nodes) clusterId",e,"nodes",a),a.forEach(a=>{if(n.children(a).length>0)x(a,n,t,r);else{let i=n.node(a);d.info("cp ",a," to ",r," with parent ",e),t.setNode(a,i),r!==n.parent(a)&&(d.warn("Setting parent",a,n.parent(a)),t.setParent(a,n.parent(a))),e!==r&&a!==e?(d.debug("Setting parent",a,e),t.setParent(a,e)):(d.info("In copy ",e,"root",r,"data",n.node(e),r),d.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==r,"node!==clusterId",a!==e));let o=n.edges(a);d.debug("Copying Edges",o),o.forEach(a=>{d.info("Edge",a);let i=n.edge(a.v,a.w,a.name);d.info("Edge data",i,r);try{C(a,r)?(d.info("Copying as ",a.v,a.w,i,a.name),t.setEdge(a.v,a.w,i,a.name),d.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):d.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",r," clusterId:",e)}catch(e){d.error(e)}})}d.debug("Removing node",a),n.removeNode(a)})},"copy"),S=n((e,n)=>{let t=n.children(e),r=[...t];for(let a of t)E.set(a,e),r=[...r,...S(a,n)];return r},"extractDescendants"),D=n((e,n,t)=>{let r=e.edges().filter(e=>e.v===n||e.w===n),a=e.edges().filter(e=>e.v===t||e.w===t),i=r.map(e=>({v:e.v===n?t:e.v,w:e.w===n?n:e.w})),d=a.map(e=>({v:e.v,w:e.w}));return i.filter(e=>d.some(n=>e.v===n.v&&e.w===n.w))},"findCommonEdges"),I=n((e,n,t)=>{let r,a=n.children(e);if(d.trace("Searching children of id ",e,a),a.length<1)return e;for(let e of a){let a=I(e,n,t),i=D(n,t,a);if(a){if(!(i.length>0))return a;r=a}}return r},"findNonClusterChild"),k=n(e=>y.has(e)&&y.get(e).externalConnections&&y.has(e)?y.get(e).id:e,"getAnchorId"),O=n((n,t)=>{if(!n||t>10)d.debug("Opting out, no graph ");else{d.debug("Opting in, graph "),n.nodes().forEach(function(e){n.children(e).length>0&&(d.warn("Cluster identified",e," Replacement id in edges: ",I(e,n,e)),X.set(e,S(e,n)),y.set(e,{id:I(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){let t=n.children(e),r=n.edges();t.length>0?(d.debug("Cluster identified",e,X),r.forEach(n=>{b(n.v,e)^b(n.w,e)&&(d.warn("Edge: ",n," leaves cluster ",e),d.warn("Descendants of XXX ",e,": ",X.get(e)),y.get(e).externalConnections=!0)})):d.debug("Not a cluster ",e,X)});for(let e of y.keys()){let t=y.get(e).id,r=n.parent(t);r!==e&&y.has(r)&&!y.get(r).externalConnections&&(y.get(e).id=r)}n.edges().forEach(function(e){let t=n.edge(e);d.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),d.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let r=e.v,a=e.w;if(d.warn("Fix XXX",y,"ids:",e.v,e.w,"Translating: ",y.get(e.v)," --- ",y.get(e.w)),y.get(e.v)&&y.get(e.w)&&y.get(e.v)===y.get(e.w)){d.warn("Fixing and trying link to self - removing XXX",e.v,e.w,e.name),d.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),r=k(e.v),a=k(e.w),n.removeEdge(e.v,e.w,e.name);let i=e.w+"---"+e.v+"---1",o=e.w+"---"+e.v+"---2";n.setNode(i,{domId:i,id:i,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setNode(o,{domId:o,id:o,labelStyle:"",padding:0,shape:"labelRect",style:"",width:10,height:10});let s=structuredClone(t),l=structuredClone(t),g=structuredClone(t);s.label="",s.arrowTypeEnd="none",s.id=e.name+"-cyclic-special-1",l.arrowTypeEnd="none",l.id=e.name+"-cyclic-special-mid",g.label="",s.fromCluster=e.v,g.toCluster=e.v,g.id=e.name+"-cyclic-special-2",n.setEdge(r,i,s,e.name+"-cyclic-special-0"),n.setEdge(i,o,l,e.name+"-cyclic-special-1"),n.setEdge(o,a,g,e.name+"-cyclic-special-2")}else if(y.get(e.v)||y.get(e.w)){if(d.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),r=k(e.v),a=k(e.w),n.removeEdge(e.v,e.w,e.name),r!==e.v){let a=n.parent(r);y.get(a).externalConnections=!0,t.fromCluster=e.v}if(a!==e.w){let r=n.parent(a);y.get(r).externalConnections=!0,t.toCluster=e.w}d.warn("Fix Replacing with XXX",r,a,e.name),n.setEdge(r,a,t,e.name)}}),d.warn("Adjusted Graph",e(n)),B(n,0),d.trace(y)}},"adjustClustersAndEdges"),B=n((n,t)=>{if(d.warn("extractor - ",t,e(n),n.children("D")),t>10)return void d.error("Bailing out");let r=n.nodes(),a=!1;for(let e of r){let t=n.children(e);a=a||t.length>0}if(a){d.debug("Nodes = ",r,t);for(let a of r)if(d.debug("Extracting node",a,y,y.has(a)&&!y.get(a).externalConnections,!n.parent(a),n.node(a),n.children("D")," Depth ",t),y.has(a))if(!y.get(a).externalConnections&&n.children(a)&&n.children(a).length>0){d.warn("Cluster without external connections, without a parent and with children",a,t);let r="TB"===n.graph().rankdir?"LR":"TB";y.get(a)?.clusterData?.dir&&(r=y.get(a).clusterData.dir,d.warn("Fixing dir",y.get(a).clusterData.dir,r));let i=new v({multigraph:!0,compound:!0}).setGraph({rankdir:r,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});d.warn("Old graph before copy",e(n)),x(a,n,i,a),n.setNode(a,{clusterNode:!0,id:a,clusterData:y.get(a).clusterData,label:y.get(a).label,graph:i}),d.warn("New graph after copy node: (",a,")",e(i)),d.debug("Old graph after copy",e(n))}else d.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!y.get(a).externalConnections," no parent: ",!n.parent(a)," children ",n.children(a)&&n.children(a).length>0,n.children("D"),t),d.debug(y);else d.debug("Not a cluster",a,t);r=n.nodes(),d.warn("New list of nodes",r);for(let e of r){let r=n.node(e);d.warn(" Now next level",e,r),r.clusterNode&&B(r.graph,t+1)}}else d.debug("Done, no node has children",n.nodes())},"extractor"),G=n((e,n)=>{if(0===n.length)return[];let t=Object.assign([],n);return n.forEach(n=>{let r=e.children(n),a=G(e,r);t=[...t,...a]}),t},"sorter"),J=n(e=>G(e,e.children()),"sortNodesByHierarchy"),P=n(async(t,r,a,i,o,v)=>{d.info("Graph in recursive render: XXX",e(r),o);let X=r.graph().rankdir;d.trace("Dir in recursive render - dir:",X);let E=t.insert("g").attr("class","root");r.nodes()?d.info("Recursive render XXX",r.nodes()):d.info("No nodes found for",r),r.edges().length>0&&d.info("Recursive edges",r.edge(r.edges()[0]));let N=E.insert("g").attr("class","clusters"),b=E.insert("g").attr("class","edgePaths"),C=E.insert("g").attr("class","edgeLabels"),x=E.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(e){let n=r.node(e);if(void 0!==o){let n=JSON.parse(JSON.stringify(o.clusterData));d.trace("Setting data for parent cluster XXX\n Node.id = ",e,"\n data=",n.height,"\nParent cluster",o.height),r.setNode(o.id,n),r.parent(e)||(d.trace("Setting parent",e,o.id),r.setParent(e,o.id,n))}if(d.info("(Insert) Node XXX"+e+": "+JSON.stringify(r.node(e))),n?.clusterNode){d.info("Cluster identified XBX",e,n.width,r.node(e));let{ranksep:t,nodesep:o}=r.graph();n.graph.setGraph({...n.graph.graph(),ranksep:t+25,nodesep:o});let g=await P(x,n.graph,a,i,r.node(e),v),c=g.elem;s(n,c),n.diff=g.diff||0,d.info("New compound node after recursive render XAX",e,"width",n.width,"height",n.height),l(c,n)}else r.children(e).length>0?(d.info("Cluster - the non recursive path XBX",e,n.id,n,n.width,"Graph:",r),d.info(I(n.id,r)),y.set(n.id,{id:I(n.id,r),node:n})):(d.trace("Node - the non recursive path XAX",e,n.id,n),await g(x,r.node(e),X))})),await n(async()=>{let e=r.edges().map(async function(e){let n=r.edge(e.v,e.w,e.name);d.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),d.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(r.edge(e))),d.info("Fix",y,"ids:",e.v,e.w,"Translating: ",y.get(e.v),y.get(e.w)),await c(C,n)});await Promise.all(e)},"processEdges")(),d.info("Graph before layout:",JSON.stringify(e(r))),d.info("############################################# XXX"),d.info("###                Layout                 ### XXX"),d.info("############################################# XXX"),m(r),d.info("Graph after layout:",JSON.stringify(e(r)));let S=0,{subGraphTitleTotalMargin:D}=f(v);return await Promise.all(J(r).map(async function(e){let n=r.node(e);if(d.info("Position XBX => "+e+": ("+n.x,","+n.y,") width: ",n.width," height: ",n.height),n?.clusterNode)n.y+=D,d.info("A tainted cluster node XBX1",e,n.id,n.width,n.height,n.x,n.y,r.parent(e)),y.get(n.id).node=n,h(n);else if(r.children(e).length>0){d.info("A pure cluster node XBX1",e,n.id,n.x,n.y,n.width,n.height,r.parent(e)),n.height+=D,r.node(n.parentId);let t=n?.padding/2||0,a=n?.labelBBox?.height||0,i=a-t||0;d.debug("OffsetY",i,"labelHeight",a,"halfPadding",t),await p(N,n),y.get(n.id).node=n}else{let e=r.node(n.parentId);n.y+=D/2,d.info("A regular node XBX1 - using the padding",n.id,"parent",n.parentId,n.width,n.height,n.x,n.y,"offsetY",n.offsetY,"parent",e,e?.offsetY,n),h(n)}})),r.edges().forEach(function(e){let n=r.edge(e);d.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n),n),n.points.forEach(e=>e.y+=D/2);let t=r.node(e.v);var o=r.node(e.w);let s=u(b,n,y,a,t,o,i);w(n,s)}),r.nodes().forEach(function(e){let n=r.node(e);d.info(e,n.type,n.diff),n.isGroup&&(S=n.diff)}),d.warn("Returning from recursive render XAX",E,S),{elem:E,diff:S}},"recursiveRender"),A=n(async(n,s)=>{let l=new v({multigraph:!0,compound:!0}).setGraph({rankdir:n.direction,nodesep:n.config?.nodeSpacing||n.config?.flowchart?.nodeSpacing||n.nodeSpacing,ranksep:n.config?.rankSpacing||n.config?.flowchart?.rankSpacing||n.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),g=s.select("g");t(g,n.markers,n.type,n.diagramId),r(),a(),i(),N(),n.nodes.forEach(e=>{l.setNode(e.id,{...e}),e.parentId&&l.setParent(e.id,e.parentId)}),d.debug("Edges:",n.edges),n.edges.forEach(e=>{l.setEdge(e.start,e.end,{...e},e.id)}),d.warn("Graph at first:",JSON.stringify(e(l))),O(l),d.warn("Graph after:",JSON.stringify(e(l)));let c=o();await P(g,l,n.type,n.diagramId,void 0,c)},"render");export{A as render};
