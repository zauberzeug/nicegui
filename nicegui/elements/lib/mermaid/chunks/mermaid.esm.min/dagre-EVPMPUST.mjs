import{a as h}from"./chunk-4BPNZXC3.mjs";import{a as B,b as G,c as T,d as A,e as R,f as F,g as M,i as Y,j,k as H,l as _,m as J}from"./chunk-RRFB4HDS.mjs";import{a as P}from"./chunk-U6LOUQAF.mjs";import"./chunk-KMOJB3TB.mjs";import{a as q}from"./chunk-BOP2KBYH.mjs";import{a as x}from"./chunk-6XGRHI2A.mjs";import"./chunk-AC3VT7B7.mjs";import"./chunk-TI4EEUUG.mjs";import{X as k,b as i}from"./chunk-NQURTBEV.mjs";import"./chunk-BKDDFIKN.mjs";import"./chunk-YPUTD6PB.mjs";import"./chunk-6BY5RJGC.mjs";import{a as u}from"./chunk-GTKDMUJJ.mjs";var l=new Map,p=new Map,z=new Map,K=u(()=>{p.clear(),z.clear(),l.clear()},"clear"),S=u((n,t)=>{let e=p.get(t)||[];return i.trace("In isDescendant",t," ",n," = ",e.includes(n)),e.includes(n)},"isDescendant"),ne=u((n,t)=>{let e=p.get(t)||[];return i.info("Descendants of ",t," is ",e),i.info("Edge is ",n),n.v===t||n.w===t?!1:e?e.includes(n.v)||S(n.v,t)||S(n.w,t)||e.includes(n.w):(i.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),Q=u((n,t,e,c)=>{i.warn("Copying children of ",n,"root",c,"data",t.node(n),c);let r=t.children(n)||[];n!==c&&r.push(n),i.warn("Copying (nodes) clusterId",n,"nodes",r),r.forEach(o=>{if(t.children(o).length>0)Q(o,t,e,c);else{let f=t.node(o);i.info("cp ",o," to ",c," with parent ",n),e.setNode(o,f),c!==t.parent(o)&&(i.warn("Setting parent",o,t.parent(o)),e.setParent(o,t.parent(o))),n!==c&&o!==n?(i.debug("Setting parent",o,n),e.setParent(o,n)):(i.info("In copy ",n,"root",c,"data",t.node(n),c),i.debug("Not Setting parent for node=",o,"cluster!==rootId",n!==c,"node!==clusterId",o!==n));let g=t.edges(o);i.debug("Copying Edges",g),g.forEach(a=>{i.info("Edge",a);let m=t.edge(a.v,a.w,a.name);i.info("Edge data",m,c);try{ne(a,c)?(i.info("Copying as ",a.v,a.w,m,a.name),e.setEdge(a.v,a.w,m,a.name),i.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):i.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",c," clusterId:",n)}catch(b){i.error(b)}})}i.debug("Removing node",o),t.removeNode(o)})},"copy"),U=u((n,t)=>{let e=t.children(n),c=[...e];for(let r of e)z.set(r,n),c=[...c,...U(r,t)];return c},"extractDescendants");var te=u((n,t,e)=>{let c=n.edges().filter(a=>a.v===t||a.w===t),r=n.edges().filter(a=>a.v===e||a.w===e),o=c.map(a=>({v:a.v===t?e:a.v,w:a.w===t?t:a.w})),f=r.map(a=>({v:a.v,w:a.w}));return o.filter(a=>f.some(m=>a.v===m.v&&a.w===m.w))},"findCommonEdges"),y=u((n,t,e)=>{let c=t.children(n);if(i.trace("Searching children of id ",n,c),c.length<1)return n;let r;for(let o of c){let f=y(o,t,e),g=te(t,e,f);if(f)if(g.length>0)r=f;else return f}return r},"findNonClusterChild"),C=u(n=>!l.has(n)||!l.get(n).externalConnections?n:l.has(n)?l.get(n).id:n,"getAnchorId"),V=u((n,t)=>{if(!n||t>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(i.warn("Cluster identified",e," Replacement id in edges: ",y(e,n,e)),p.set(e,U(e,n)),l.set(e,{id:y(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){let c=n.children(e),r=n.edges();c.length>0?(i.debug("Cluster identified",e,p),r.forEach(o=>{let f=S(o.v,e),g=S(o.w,e);f^g&&(i.warn("Edge: ",o," leaves cluster ",e),i.warn("Descendants of XXX ",e,": ",p.get(e)),l.get(e).externalConnections=!0)})):i.debug("Not a cluster ",e,p)});for(let e of l.keys()){let c=l.get(e).id,r=n.parent(c);r!==e&&l.has(r)&&!l.get(r).externalConnections&&(l.get(e).id=r)}n.edges().forEach(function(e){let c=n.edge(e);i.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let r=e.v,o=e.w;if(i.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l.get(e.v)," --- ",l.get(e.w)),l.get(e.v)&&l.get(e.w)&&l.get(e.v)===l.get(e.w)){i.warn("Fixing and trying link to self - removing XXX",e.v,e.w,e.name),i.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),r=C(e.v),o=C(e.w),n.removeEdge(e.v,e.w,e.name);let f=e.w+"---"+e.v+"---1",g=e.w+"---"+e.v+"---2";n.setNode(f,{domId:f,id:f,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setNode(g,{domId:g,id:g,labelStyle:"",padding:0,shape:"labelRect",style:"",width:10,height:10});let a=structuredClone(c),m=structuredClone(c),b=structuredClone(c);a.label="",a.arrowTypeEnd="none",a.id=e.name+"-cyclic-special-1",m.arrowTypeEnd="none",m.id=e.name+"-cyclic-special-mid",b.label="",a.fromCluster=e.v,b.toCluster=e.v,b.id=e.name+"-cyclic-special-2",n.setEdge(r,f,a,e.name+"-cyclic-special-0"),n.setEdge(f,g,m,e.name+"-cyclic-special-1"),n.setEdge(g,o,b,e.name+"-cyclic-special-2")}else if(l.get(e.v)||l.get(e.w)){if(i.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),r=C(e.v),o=C(e.w),n.removeEdge(e.v,e.w,e.name),r!==e.v){let f=n.parent(r);l.get(f).externalConnections=!0,c.fromCluster=e.v}if(o!==e.w){let f=n.parent(o);l.get(f).externalConnections=!0,c.toCluster=e.w}i.warn("Fix Replacing with XXX",r,o,e.name),n.setEdge(r,o,c,e.name)}}),i.warn("Adjusted Graph",h(n)),W(n,0),i.trace(l)},"adjustClustersAndEdges"),W=u((n,t)=>{if(i.warn("extractor - ",t,h(n),n.children("D")),t>10){i.error("Bailing out");return}let e=n.nodes(),c=!1;for(let r of e){let o=n.children(r);c=c||o.length>0}if(!c){i.debug("Done, no node has children",n.nodes());return}i.debug("Nodes = ",e,t);for(let r of e)if(i.debug("Extracting node",r,l,l.has(r)&&!l.get(r).externalConnections,!n.parent(r),n.node(r),n.children("D")," Depth ",t),!l.has(r))i.debug("Not a cluster",r,t);else if(!l.get(r).externalConnections&&n.children(r)&&n.children(r).length>0){i.warn("Cluster without external connections, without a parent and with children",r,t);let f=n.graph().rankdir==="TB"?"LR":"TB";l.get(r)?.clusterData?.dir&&(f=l.get(r).clusterData.dir,i.warn("Fixing dir",l.get(r).clusterData.dir,f));let g=new x({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",h(n)),Q(r,n,g,r),n.setNode(r,{clusterNode:!0,id:r,clusterData:l.get(r).clusterData,label:l.get(r).label,graph:g}),i.warn("New graph after copy node: (",r,")",h(g)),i.debug("Old graph after copy",h(n))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!l.get(r).externalConnections," no parent: ",!n.parent(r)," children ",n.children(r)&&n.children(r).length>0,n.children("D"),t),i.debug(l);e=n.nodes(),i.warn("New list of nodes",e);for(let r of e){let o=n.node(r);i.warn(" Now next level",r,o),o.clusterNode&&W(o.graph,t+1)}},"extractor"),Z=u((n,t)=>{if(t.length===0)return[];let e=Object.assign([],t);return t.forEach(c=>{let r=n.children(c),o=Z(n,r);e=[...e,...o]}),e},"sorter"),$=u(n=>Z(n,n.children()),"sortNodesByHierarchy");var L=u(async(n,t,e,c,r,o)=>{i.info("Graph in recursive render: XXX",h(t),r);let f=t.graph().rankdir;i.trace("Dir in recursive render - dir:",f);let g=n.insert("g").attr("class","root");t.nodes()?i.info("Recursive render XXX",t.nodes()):i.info("No nodes found for",t),t.edges().length>0&&i.info("Recursive edges",t.edge(t.edges()[0]));let a=g.insert("g").attr("class","clusters"),m=g.insert("g").attr("class","edgePaths"),b=g.insert("g").attr("class","edgeLabels"),O=g.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(d){let s=t.node(d);if(r!==void 0){let w=JSON.parse(JSON.stringify(r.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,d,`
 data=`,w.height,`
Parent cluster`,r.height),t.setNode(r.id,w),t.parent(d)||(i.trace("Setting parent",d,r.id),t.setParent(d,r.id,w))}if(i.info("(Insert) Node XXX"+d+": "+JSON.stringify(t.node(d))),s?.clusterNode){i.info("Cluster identified XBX",d,s.width,t.node(d));let{ranksep:w,nodesep:X}=t.graph();s.graph.setGraph({...s.graph.graph(),ranksep:w+25,nodesep:X});let v=await L(O,s.graph,e,c,t.node(d),o),N=v.elem;Y(s,N),s.diff=v.diff||0,i.info("New compound node after recursive render XAX",d,"width",s.width,"height",s.height),H(N,s)}else t.children(d).length>0?(i.info("Cluster - the non recursive path XBX",d,s.id,s,s.width,"Graph:",t),i.info(y(s.id,t)),l.set(s.id,{id:y(s.id,t),node:s})):(i.trace("Node - the non recursive path XAX",d,s.id,s),await j(O,t.node(d),f))})),await u(async()=>{let d=t.edges().map(async function(s){let w=t.edge(s.v,s.w,s.name);i.info("Edge "+s.v+" -> "+s.w+": "+JSON.stringify(s)),i.info("Edge "+s.v+" -> "+s.w+": ",s," ",JSON.stringify(t.edge(s))),i.info("Fix",l,"ids:",s.v,s.w,"Translating: ",l.get(s.v),l.get(s.w)),await A(b,w)});await Promise.all(d)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(h(t))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),q(t),i.info("Graph after layout:",JSON.stringify(h(t)));let D=0,{subGraphTitleTotalMargin:E}=P(o);return await Promise.all($(t).map(async function(d){let s=t.node(d);if(i.info("Position XBX => "+d+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s?.clusterNode)s.y+=E,i.info("A tainted cluster node XBX1",d,s.id,s.width,s.height,s.x,s.y,t.parent(d)),l.get(s.id).node=s,J(s);else if(t.children(d).length>0){i.info("A pure cluster node XBX1",d,s.id,s.x,s.y,s.width,s.height,t.parent(d)),s.height+=E,t.node(s.parentId);let w=s?.padding/2||0,X=s?.labelBBox?.height||0,v=X-w||0;i.debug("OffsetY",v,"labelHeight",X,"halfPadding",w),await B(a,s),l.get(s.id).node=s}else{let w=t.node(s.parentId);s.y+=E/2,i.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",w,w?.offsetY,s),J(s)}})),t.edges().forEach(function(d){let s=t.edge(d);i.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(s),s),s.points.forEach(N=>N.y+=E/2);let w=t.node(d.v);var X=t.node(d.w);let v=F(m,s,l,e,w,X,c);R(s,v)}),t.nodes().forEach(function(d){let s=t.node(d);i.info(d,s.type,s.diff),s.isGroup&&(D=s.diff)}),i.warn("Returning from recursive render XAX",g,D),{elem:g,diff:D}},"recursiveRender"),be=u(async(n,t)=>{let e=new x({multigraph:!0,compound:!0}).setGraph({rankdir:n.direction,nodesep:n.config?.nodeSpacing||n.config?.flowchart?.nodeSpacing||n.nodeSpacing,ranksep:n.config?.rankSpacing||n.config?.flowchart?.rankSpacing||n.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),c=t.select("g");M(c,n.markers,n.type,n.diagramId),_(),T(),G(),K(),n.nodes.forEach(o=>{e.setNode(o.id,{...o}),o.parentId&&e.setParent(o.id,o.parentId)}),i.debug("Edges:",n.edges),n.edges.forEach(o=>{e.setEdge(o.start,o.end,{...o},o.id)}),i.warn("Graph at first:",JSON.stringify(h(e))),V(e),i.warn("Graph after:",JSON.stringify(h(e)));let r=k();await L(c,e,n.type,n.diagramId,void 0,r)},"render");export{be as render};
