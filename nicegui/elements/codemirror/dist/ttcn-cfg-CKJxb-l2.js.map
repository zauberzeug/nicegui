{"version":3,"file":"ttcn-cfg-CKJxb-l2.js","sources":["../node_modules/@codemirror/legacy-modes/mode/ttcn-cfg.js"],"sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i)\n    obj[words[i]] = true;\n  return obj;\n}\n\nconst parserConfig = {\n  name: \"ttcn-cfg\",\n  keywords: words(\"Yes No LogFile FileMask ConsoleMask AppendFile\" +\n                  \" TimeStampFormat LogEventTypes SourceInfoFormat\" +\n                  \" LogEntityName LogSourceInfo DiskFullAction\" +\n                  \" LogFileNumber LogFileSize MatchingHints Detailed\" +\n                  \" Compact SubCategories Stack Single None Seconds\" +\n                  \" DateTime Time Stop Error Retry Delete TCPPort KillTimer\" +\n                  \" NumHCs UnixSocketsEnabled LocalAddress\"),\n  fileNCtrlMaskOptions: words(\"TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING\" +\n                              \" TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP\" +\n                              \" TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION\" +\n                              \" TTCN_USER TTCN_FUNCTION TTCN_STATISTICS\" +\n                              \" TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG\" +\n                              \" EXECUTOR ERROR WARNING PORTEVENT TIMEROP\" +\n                              \" VERDICTOP DEFAULTOP TESTCASE ACTION USER\" +\n                              \" FUNCTION STATISTICS PARALLEL MATCHING DEBUG\" +\n                              \" LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED\" +\n                              \" DEBUG_ENCDEC DEBUG_TESTPORT\" +\n                              \" DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE\" +\n                              \" DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT\" +\n                              \" DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED\" +\n                              \" EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA\" +\n                              \" EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS\" +\n                              \" EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED\" +\n                              \" FUNCTION_RND FUNCTION_UNQUALIFIED\" +\n                              \" MATCHING_DONE MATCHING_MCSUCCESS\" +\n                              \" MATCHING_MCUNSUCC MATCHING_MMSUCCESS\" +\n                              \" MATCHING_MMUNSUCC MATCHING_PCSUCCESS\" +\n                              \" MATCHING_PCUNSUCC MATCHING_PMSUCCESS\" +\n                              \" MATCHING_PMUNSUCC MATCHING_PROBLEM\" +\n                              \" MATCHING_TIMEOUT MATCHING_UNQUALIFIED\" +\n                              \" PARALLEL_PORTCONN PARALLEL_PORTMAP\" +\n                              \" PARALLEL_PTC PARALLEL_UNQUALIFIED\" +\n                              \" PORTEVENT_DUALRECV PORTEVENT_DUALSEND\" +\n                              \" PORTEVENT_MCRECV PORTEVENT_MCSEND\" +\n                              \" PORTEVENT_MMRECV PORTEVENT_MMSEND\" +\n                              \" PORTEVENT_MQUEUE PORTEVENT_PCIN\" +\n                              \" PORTEVENT_PCOUT PORTEVENT_PMIN\" +\n                              \" PORTEVENT_PMOUT PORTEVENT_PQUEUE\" +\n                              \" PORTEVENT_STATE PORTEVENT_UNQUALIFIED\" +\n                              \" STATISTICS_UNQUALIFIED STATISTICS_VERDICT\" +\n                              \" TESTCASE_FINISH TESTCASE_START\" +\n                              \" TESTCASE_UNQUALIFIED TIMEROP_GUARD\" +\n                              \" TIMEROP_READ TIMEROP_START TIMEROP_STOP\" +\n                              \" TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED\" +\n                              \" USER_UNQUALIFIED VERDICTOP_FINAL\" +\n                              \" VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT\" +\n                              \" VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED\"),\n  externalCommands: words(\"BeginControlPart EndControlPart BeginTestCase\" +\n                          \" EndTestCase\"),\n  multiLineStrings: true\n}\n\nvar keywords = parserConfig.keywords,\n    fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions,\n    externalCommands = parserConfig.externalCommands,\n    multiLineStrings = parserConfig.multiLineStrings,\n    indentStatements = parserConfig.indentStatements !== false;\nvar isOperatorChar = /[\\|]/;\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (/[:=]/.test(ch)) {\n    curPunc = ch;\n    return \"punctuation\";\n  }\n  if (ch == \"#\"){\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  if (ch == \"[\"){\n    stream.eatWhile(/[\\w_\\]]/);\n    return \"number\";\n  }\n\n  stream.eatWhile(/[\\w\\$_]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))\n    return \"atom\";\n  if (externalCommands.propertyIsEnumerable(cur)) return \"deleted\";\n\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped){\n        var afterNext = stream.peek();\n        //look if the character if the quote is like the B in '10100010'B\n        if (afterNext){\n          afterNext = afterNext.toLowerCase();\n          if(afterNext == \"b\" || afterNext == \"h\" || afterNext == \"o\")\n            stream.next();\n        }\n        end = true; break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !(escaped || multiLineStrings))\n      state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n//Interface\nexport const ttcnCfg = {\n  name: \"ttcn\",\n  startState: function() {\n    return {\n      tokenize: null,\n      context: new Context(0, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n\n  token: function(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\") return style;\n    if (ctx.align == null) ctx.align = true;\n\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\")\n        && ctx.type == \"statement\"){\n      popContext(state);\n    }\n    else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n    else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n    else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n    else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n      if (ctx.type == \"}\") ctx = popContext(state);\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    }\n    else if (curPunc == ctx.type) popContext(state);\n    else if (indentStatements && (((ctx.type == \"}\" || ctx.type == \"top\")\n                                   && curPunc != ';') || (ctx.type == \"statement\"\n                                                          && curPunc == \"newstatement\")))\n      pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["words","str","obj","split","i","length","parserConfig","keywords","fileNCtrlMaskOptions","externalCommands","curPunc","indentStatements","isOperatorChar","tokenBase","stream","state","quote","ch","next","tokenize","escaped","end","afterNext","peek","toLowerCase","test","skipToEnd","eatWhile","cur","current","propertyIsEnumerable","Context","indented","column","type","align","prev","this","pushContext","col","indent","context","popContext","t","ttcnCfg","name","startState","startOfLine","token","ctx","sol","indentation","eatSpace","style","languageData","indentOnInput","commentTokens","line"],"mappings":"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","x_google_ignoreList":[0]}
